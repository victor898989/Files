import FreeCAD as App
import FreeCADGui as Gui
import Part
import math

# Crear o activar documento
doc_name="Direct_Fusion_Drive"
if App.ActiveDocument is None or App.ActiveDocument.Label!=doc_name:
    App.newDocument(doc_name)
doc=App.ActiveDocument

# ------------------ Parámetros base y configuraciones ------------------
# Aquí puedes ajustar parámetros generales
P={"nose_len":800.0,"nose_base_d":600.0,"mid_len":1400.0,"mid_d":900.0,
   "rear_len":800.0,"rear_d":1200.0,"hull_t":10.0,
   "reactor_cx":2600.0,
   "nozzle_throat_d":300.0,"nozzle_exit_d":900.0,"nozzle_l":700.0,"nozzle_cx":2850.0,
   "rad_panel_w":800.0,"rad_panel_h":600.0,"rad_panel_n":5}

TPS={"tps_d":2400.0,"tps_t":100.0,"tps_gap":120.0,"sup_L":280.0,"sup_d_base":900.0,"sup_d_tip":600.0,
     "cer_t":5.0,"cc_shield_t":20.0}

TK={
  "Rm":300.0, "r_sec":90.0, "t_wall":8.0,
  "cry_gap":35.0, "cry_t":16.0,
  "N_TF":24, "TF_flat":120.0, "TF_th":16.0,
  "N_PF":8, "PF_r":26.0, "PF_R":250.0, "PF_span":900.0,
  "sol_R":140.0, "sol_r":42.0, "sol_L":700.0,
  "N_ports":8, "D_port":150.0, "L_port":240.0,
  "N_RF":4, "RF_R":310.0, "RF_r":16.0, "RF_phase_deg":22.5,
  "variant":"aerospike", "Ae_Ar":6.0, "ann_gap":18.0, "ann_len":70.0
}

# Materiales extendidos con propiedades físicas adicionales
MAT={
    'AL': ('AA-2xxx', 2700.0, 0.3, 150), # Conductividad térmica en W/m*K
    '316L':('SS-316L', 7980.0, 0.8, 16),
    '718':('Inconel-718', 8190.0, 0.9, None),
    'CFRP':('CFRP', 1550.0, 0.5, 7e-6),
    '6061':('AA-6061-T6', 2710.0, 0.4, None),
    'Cu': ('Copper', 8960.0, 0.2, 400),
    'CC': ('C/C TPS', 1600.0, 0.95, None),
    'CER': ('SiC Liner', 3200.0, 0.98, 80),
    'CC_Noz': ('C/C Nozzle', 1600.0, 0.95, None),
    'CER_Coat': ('SiC Coating', 3200.0, 0.98, 80),
    'CC_Shield': ('C/C Shield', 1600.0, 0.95, None)
}

# Vectores básicos
X=App.Vector(1,0,0)
Y=App.Vector(0,1,0)
Z=App.Vector(0,0,1)

def rot_to_x():
    return App.Rotation(Y,90)

# Función para agregar objetos y asignar color
def add_obj(shape,label,color=(0.2,0.4,0.8)):
    o=doc.addObject("Part::Feature",label)
    o.Shape=shape
    try:
        o.ViewObject.ShapeColor=color
    except:
        pass
    return o

# Función para asignar propiedades de material
def set_mat(o,key):
    if key not in MAT:
        print(f"Material {key} no definido.")
        return
    name, rho, corr_res, therm_cond = MAT[key]
    o.addProperty("App::PropertyString","Material","Meta","").Material=name
    o.addProperty("App::PropertyFloat","Density","Meta","").Density=rho
    o.addProperty("App::PropertyFloat","Corrosion_Resistance","Meta","").Corrosion_Resistance=corr_res
    if therm_cond:
        o.addProperty("App::PropertyFloat","Thermal_Conductivity","Meta","").Thermal_Conductivity=therm_cond
    # Calcular masa automática
    vol = o.Shape.Volume/1e9
    o.addProperty("App::PropertyFloat","Mass","Meta","").Mass=vol*rho

# Función para calcular totales de masa y resistencia
def calculate_totals(objects):
    total_mass=0.0
    total_corr_res=0.0
    total_vol=0.0
    for o in objects:
        if hasattr(o,"Mass") and hasattr(o,"Corrosion_Resistance") and hasattr(o.Shape,"Volume"):
            mass=o.Mass
            corr=o.Corrosion_Resistance
            vol=o.Shape.Volume/1e9
            total_mass+=mass
            total_corr_res+=corr*vol
            total_vol+=vol
    avg_corr_res=total_corr_res/total_vol if total_vol>0 else 0
    return total_mass, avg_corr_res

# Funciones básicas de modelado
def cylX(d,L,c=(0,0,0),label="CylX",color=(0.2,0.4,0.8)):
    s=Part.makeCylinder(d/2.0, L)
    s.Placement=App.Placement(App.Vector(c[0]-L/2.0,c[1],c[2]),rot_to_x())
    o=add_obj(s,label,color)
    return o

def coneX(d1,d2,L,c=(0,0,0),label="ConeX",color=(0.2,0.4,0.8)):
    s=Part.makeCone(d1/2.0, d2/2.0, L)
    s.Placement=App.Placement(App.Vector(c[0]-L/2.0,c[1],c[2]),rot_to_x())
    o=add_obj(s,label,color)
    return o

def torusX(R,r,c=(0,0,0),label="TorusX",color=(0.2,0.4,0.8)):
    s=Part.makeTorus(R,r)
    s.Placement=App.Placement(App.Vector(c[0],c[1],c[2]),rot_to_x())
    o=add_obj(s,label,color)
    return o

def box(w,d,h,c=(0,0,0),label="Box",color=(0.2,0.4,0.8)):
    s=Part.makeBox(w,d,h)
    s.Placement=App.Placement(App.Vector(c[0]-w/2,c[1]-d/2,c[2]-h/2),App.Rotation())
    o=add_obj(s,label,color)
    return o

def shell_from_solid(solid,t,label):
    try:
        inner=solid.makeOffsetShape(-t,0.02,join=2,fill=True)
        shell=solid.cut(inner)
        if shell.Volume>0:
            o=add_obj(shell,label)
            return o
        else:
            raise ValueError("Volumen de concha inválido")
    except Exception as e:
        print(f"Warning: Fallo en create shell for {label}: {e}")
        return add_obj(solid,label+"_fallback")

# ------------------ Infraestructura adicional (capas, recubrimientos, soportes) ------------------

def add_coating(parent_obj,thickness,material_key,label_suffix="_Coat"):
    shell=shell_from_solid(parent_obj.Shape,thickness,parent_obj.Name+label_suffix)
    set_mat(shell,material_key)
    return shell

def add_support_structure(position,size,material_key,label):
    support=box(size[0],size[1],size[2],position,label)
    set_mat(support,material_key)
    return support

def add_layered_shield(diameter,thickness,material_key,position,label_prefix):
    shell=shell_from_solid(Part.makeCylinder(diameter/2,thickness),thickness,label_prefix)
    set_mat(shell,material_key)
    shell.Placement.Base=position
    return shell

# ------------------ Modelo de la nave y estructura externa ------------------
tip = P["nose_len"]
# Casco + capas multicapa
nose=coneX(P["nose_base_d"],0.0,P["nose_len"],(tip/2,0,0),"Nose"); set_mat(nose,'AL')
mid=cylX(P["mid_d"],P["mid_len"],(P["nose_len"]+P["mid_len"]/2,0,0),"Mid"); set_mat(mid,'AL')
rear=cylX(P["rear_d"],P["rear_len"],(P["nose_len"]+P["mid_len"]+P["rear_len"]/2,0,0),"Rear"); set_mat(rear,'AL')
hull_outer=hull=hull_outer=Part.makeFuse(nose.Shape,mid.Shape)
hull_outer=hull.Shape.fuse(rear.Shape)
hull= shell_from_solid(hull_outer, P["hull_t"], "Hull_Shell"); set_mat(hull,'AL')

# Protección térmica y revestimientos cerámicos
hull_cer= shell_from_solid(hull.Shape, 2.0, "Hull_Ceramic_Coat"); 
set_mat(hull_cer,'CER')
add_coating(hull,2.0,'CER',"Hull_Protect")

# Capas adicionales: blindaje térmico
protector=add_layered_shield(P["mid_d"]+100, 10, 'AL', App.Vector(P["nose_len"]+P["mid_len"]+P["rear_len"],0,0),"Thermal_Shield")
set_mat(protector,'AL')
# Cambiar color para visualización
protector.ViewObject.ShapeColor=(0.8,0.1,0.1)

# ------------------ Soporte TPS y revestimientos ------------------
# Soporte TPS
tps_support=coneX(TPS["sup_d_base"], TPS["sup_d_tip"], TPS["sup_L"],
                   (tip+TPS["tps_gap"]+TPS["sup_L"]/2,0,0),"TPS_Support"); set_mat(tps_support,'316L')

# Revestimiento cerámico
tps_cer= cylX(TPS["tps_d"], TPS["cer_t"], (tip+TPS["tps_gap"]+TPS["sup_L"],0,0),"TPS_Ceramic")
set_mat(tps_cer,'CER')

# Núcleo C/C
tps_core= cylX(TPS["tps_d"], TPS["tps_t"], (tip+TPS["tps_gap"]+TPS["sup_L"]+TPS["cer_t"],0,0),"TPS_Core")
set_mat(tps_core,'CC')

# Capa de protección C/C
tps_shield= cylX(TPS["tps_d"]+TPS["cc_shield_t"]*2, TPS["cc_shield_t"],
                 (tip+TPS["tps_gap"]+TPS["sup_L"]+TPS["cer_t"]+TPS["tps_t"],0,0),"TPS_CC_Shield")
set_mat(tps_shield,'CC_Shield')

# Anillo disipador
tps_ring_o=cylX(TPS["tps_d"]+120,20,
                (tip+TPS["tps_gap"]+TPS["sup_L"]+TPS["cer_t"]+TPS["tps_t"]+TPS["cc_shield_t"]+10,0,0),"TPS_Ring_O")
tps_ring_i=cylX(TPS["tps_d"]+40,18,
                (tip+TPS["tps_gap"]+TPS["sup_L"]+TPS["cer_t"]+TPS["tps_t"]+TPS["cc_shield_t"]+11,0,0),"TPS_Ring_I")
tps_ring=add_obj(tps_ring_o.Shape.cut(tps_ring_i.Shape),"TPS_Diss_Ring")
set_mat(tps_ring,'AL')
tps_ring.ViewObject.ShapeColor=(0.5,0.6,0.7)

# ------------------ Tokamak de hidrógeno ------------------
cx= P["reactor_cx"]
# Cascarón y liner cerámico
toro_s=torusX(TK["Rm"],TK["r_sec"],(cx,0,0),"Toro_Solid"); set_mat(toro_s,"316L")
toro= shell_from_solid(toro_s.Shape, TK["t_wall"], "Toro_316L")
set_mat(toro,'316L')

liner_i=torusX(TK["Rm"],TK["r_sec"]-TK["t_wall"]-6.0,(cx,0,0),"Liner_Solid")
liner= shell_from_solid(liner_i.Shape,6.0,"Liner_CER")
set_mat(liner,'CER')

# Camisa intermedia
jacket_s=torusX(TK["Rm"],TK["r_sec"]-2.0,(cx,0,0),"Jacket_Solid")
jacket= shell_from_solid(jacket_s.Shape,4.0,"Jacket_316L")
set_mat(jacket,'316L')

# Criostato doble capa
cry_o=torusX(TK["Rm"]+TK["cry_gap"]+TK["cry_t"],TK["r_sec"],(cx,0,0),"Cryostat_O")
cry_i=torusX(TK["Rm"]+TK["cry_gap"],TK["r_sec"]-TK["t_wall"],(cx,0,0),"Cryostat_I")
cry= add_obj(cry_o.Shape.cut(cry_i.Shape),"Cryostat")
set_mat(cry,'AL')

cry_shield=torusX(TK["Rm"]+TK["cry_gap"]+TK["cry_t"]+20,15,(cx,0,0),"Cryostat_CC_Shield")
set_mat(cry_shield,'CC_Shield')

# ------------------ Electroimanes (solenoides y bobinas) ------------------
# Bobinas TF (Densas)
TF=[]
for k in range(TK["N_TF"]):
    a=360.0/TK["N_TF"]*k
    frame_o=torusX(TK["Rm"],TK["TF_flat"]/2,(cx,0,0),f"TFo_{k:02d}")
    frame_i=torusX(TK["Rm"],TK["TF_flat"]/2 - TK["TF_th"],(cx,0,0),f"TFi_{k:02d}")
    tf=add_obj(frame_o.Shape.cut(frame_i.Shape),f"TF_{k:02d}",(0.85,0.5,0.2))
    set_mat(tf,'Cu')
    tf.Placement=App.Placement(tf.Placement.Base,App.Rotation(X,a))
    TF.append(tf)

# Bobinas PF
PF=[]
for k in range(TK["N_PF"]):
    z= (-TK["N_PF"]/2 + 0.5 + k)*(TK["PF_span"]/TK["N_PF"])
    pf=torusX(TK["PF_R"],TK["PF_r"],(cx,0,z),"PF_{k:02d}")
    set_mat(pf,'Cu')
    PF.append(pf)

# Solenoide axial
sol_o= cylX(2*TK["sol_R"],TK["sol_L"],(cx,0,-TK["sol_L"]/2),"Solenoid_O")
sol_i= cylX(2*(TK["sol_R"]-TK["sol_r"]),TK["sol_L"]*0.98,(cx+0.02*TK["sol_L"],0,-TK["sol_L"]/2),"Solenoid_I")
sol= add_obj(sol_o.Shape.cut(sol_i.Shape),"Solenoid")
set_mat(sol,'Cu')

# Puertos diagnósticos y líneas RF
ports=[]
for i in range(TK["N_ports"]):
    ang=2*math.pi*i/TK["N_ports"]
    x=cx
    y=(TK["Rm"]+TK["r_sec"]+50.0)*math.cos(ang)
    z=(TK["Rm"]+TK["r_sec"]+50.0)*math.sin(ang)
    axis=App.Vector(math.cos(ang),math.sin(ang),0)
    p=Part.makeCylinder(TK["D_port"]/2.0, TK["L_port"], App.Vector(x,y,z), axis)
    port_obj=add_obj(p,f"Port_{i:02d}",(0.5,0.6,0.7))
    set_mat(port_obj,'316L')
    ports.append(port_obj)

loops=[]
for i in range(TK["N_RF"]):
    a=360.0/TK["N_RF"]*i + TK["RF_phase_deg"]
    rf=torusX(TK["RF_R"],TK["RF_r"],(cx,0,0),f"RF_{i:02d}")
    rf.Placement=App.Placement(rf.Placement.Base,App.Rotation(X,a))
    set_mat(rf,'Cu')
    loops.append(rf)

# Manifold y líneas H2
manif= cylX(220,300,(cx+TK["sol_L"]/2+220,0,-TK["r_sec"]*0.75),"Manifold")
set_mat(manif,'316L')
line_L= cylX(20,800,(cx-400,-P["mid_d"]/2-40,-60),"H2_Line_L")
set_mat(line_L,'CC')
line_R= cylX(20,800,(cx-400,P["mid_d"]/2+40,-60),"H2_Line_R")
set_mat(line_R,'CC')

# Nozzle aeroespike y anular
noz_cone= coneX(P["nozzle_throat_d"], P["nozzle_exit_d"], P["nozzle_l"], (P["nozzle_cx"],0,0),"Nozzle_Aerospike")
set_mat(noz_cone,'CC_Noz')
At=math.pi*(P["nozzle_exit_d"]/2)**2 / TK["Ae_Ar"]
dg= max(120.0,2*math.sqrt(At/math.pi))
ann_o= cylX(P["nozzle_exit_d"], TK["ann_len"], (P["nozzle_cx"]+P["nozzle_l"],0,0),"Nozzle_Ann_O")
ann_i= cylX(P["nozzle_exit_d"]-2*TK["ann_gap"], TK["ann_len"]*0.96, (P["nozzle_cx"]+P["nozzle_l"]+TK["ann_len"]/2,0,0),"Nozzle_Ann_I")
noz_ann= add_obj(ann_o.Shape.cut(ann_i.Shape),"Nozzle_Annulus")
set_mat(noz_ann,'316L')
if TK["variant"]=="aerospike": noz_ann.ViewObject.Visibility=False
else: noz_cone.ViewObject.Visibility=False

# ------------------ Radiadores (en paralelo, con protección extra) ------------------
RAD={"x_start":P["reactor_cx"]+240,"gap_x":P["rad_panel_w"]+80,"th":4,"mount_gap_y":30}
rads=[]
for i in range(P["rad_panel_n"]):
    x=RAD["x_start"]+i*RAD["gap_x"]
    for s in [-1,1]:
        plate=box(P["rad_panel_w"],RAD["th"],P["rad_panel_h"],(x,s*(P["mid_d"]/2+RAD["mount_gap_y"]),0),"Rad_{i}_{s}")
        set_mat(plate,'CFRP')
        rads.append(plate)

# ------------------ Capas de colores y visualización ------------------
# Asignar colores específicos por capa
layer_colors={
    "Hull_Shell":(0.1,0.3,0.6),
    "Hull_Ceramic_Coat":(0.95,0.95,0.98),
    "TPS_Core":(0.05,0.05,0.05),
    "TPS_Support":(0.4,0.4,0.45),
    "TPS_Ceramic":(0.9,0.9,0.95),
    "TPS_CC_Shield":(0.1,0.1,0.1),
    "Cryostat":(0.6,0.75,0.95),
    "Cryostat_CC_Shield":(0.1,0.1,0.1),
    "Toro_316L":(0.35,0.55,0.85),
    "Liner_CER":(0.9,0.9,0.95),
    "Jacket_316L":(0.45,0.65,0.9),
    "Cryostat":(0.6,0.75,0.95),
    "Cryostat_CC_Shield":(0.1,0.1,0.1),
    "Nozzle_Aerospike":(0.1,0.1,0.1),
    "Nozzle_Annulus":(0.55,0.55,0.6),
    "Thermal_Shield":(0.8,0.1,0.1), # ejemplo
}

# Aplicar colores personalizados
for name,color in layer_colors.items():
    obj=doc.getObject(name)
    if obj:
        obj.ViewObject.ShapeColor=color

# Recalcular
doc.recompute()

# ------------------ Cálculo de totales (masa, centro de gravedad) ------------------
all_objects = [nose, mid, rear, hull, hull_cer, tps_support, tps_cer, tps_core, tps_shield,
               tps_ring, toro, liner, jacket, cry, cry_shield] + TF + PF + [sol] + ports + loops + [manif, line_L, line_R, noz_cone, noz_ann] + rads
total_mass, avg_corr_res = calculate_totals(all_objects)
print(f"Total Mass: {total_mass:.2f} kg")
print(f"Average Corrosion Resistance: {avg_corr_res:.3f}")

# ------------------ Centro de gravedad (opcional avanzado) ------------------
def compute_center_of_gravity(objects):
    total_mass=0.0
    weighted_pos=App.Vector(0,0,0)
    for o in objects:
        if hasattr(o,"Mass") and hasattr(o.Placement,"Base"):
            m=o.Mass
            pos=o.Placement.Base
            total_mass+=m
            weighted_pos+=pos * m
    if total_mass>0:
        return weighted_pos/total_mass
    return App.Vector(0,0,0)

cog= compute_center_of_gravity(all_objects)
print(f"Centro de gravedad aproximado: {cog}")

# ------------------ Comentarios finales
print("Macro ampliado y con mejoras en materiales, capas y visualización técnico.")
